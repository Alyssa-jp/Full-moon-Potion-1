<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Potion App (single file)</title>
  <style>
    *{box-sizing:border-box}html,body{margin:0;height:100%;background:#0d0f13;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #app{position:fixed;inset:0;display:grid;place-items:center}
    #stage{width:100%;height:100%;max-height:100vh;touch-action:none;background:#111;
      background-image:radial-gradient(1200px 1200px at 50% 10%,rgba(30,60,90,.35),transparent),
                       radial-gradient(800px 800px at 70% 80%,rgba(60,30,90,.25),transparent)}
    .ui-btn{position:fixed;top:12px;right:12px;border:none;background:rgba(0,0,0,.45);color:#fff;padding:8px 12px;margin-left:8px;border-radius:10px;font-size:18px;backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px)}
    #btn-help{right:auto;left:12px}
    .overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.45);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px)}
    .panel{background:#141821;border:1px solid #2a3242;border-radius:16px;padding:20px 24px;max-width:92vw}
    .panel h1{margin:.2em 0 .2em;font-size:22px}.panel p{margin:.5em 0}.small{opacity:.8;font-size:13px}
    .primary{appearance:none;border:none;border-radius:12px;padding:12px 16px;background:#4aa3ff;color:#0a0f15;font-weight:700}
    .toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.7);padding:10px 14px;border-radius:10px}
  </style>
</head>
<body>
  <div id="app">
    <canvas id="stage" width="1080" height="1920"></canvas>

    <button id="btn-audio" aria-label="toggle sound" class="ui-btn">🔊</button>
    <button id="btn-help" aria-label="help" class="ui-btn">?</button>

    <div id="overlay" class="overlay">
      <div class="panel">
        <h1>ポーション</h1>
        <p>キャップをタップ → 揺らす → 傾けると注げます。</p>
        <p class="small">iOSでは最初に“センサー使用”の許可が必要です。</p>
        <button id="btn-start" class="primary">はじめる</button>
      </div>
    </div>

    <div id="toast" class="toast" hidden></div>
  </div>

  <script>
  // ===== Audio helper (no external files) =====
  class AudioBus {
    constructor(){
      this.ctx = null; this.buffers = new Map(); this.gains = new Map();
      this.currentLoops = new Map(); this.enabled = true;
    }
    async init(map){
      if (this.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      this.ctx = new Ctx();
      if (this.ctx.state === "suspended") { try{ await this.ctx.resume(); }catch{} }
      this.master = this.ctx.createGain(); this.master.gain.value = 1.0; this.master.connect(this.ctx.destination);
      this.map = map;
      await Promise.all(Object.entries(map).map(async ([key,spec])=>{
        const buf = await this._fetchDecode(spec.file);
        this.buffers.set(key, buf);
        const g = this.ctx.createGain(); g.gain.value = spec.gain ?? 1; g.connect(this.master);
        this.gains.set(key, g);
      }));
    }
    async _fetchDecode(url){
      const res = await fetch(url); if(!res.ok) throw new Error(res.status);
      const ab  = await res.arrayBuffer();
      return await new Promise((ok,ng)=> (this.ctx.decodeAudioData(ab, ok, ng)));
    }
    setEnabled(v){ this.enabled = !!v; if(this.master) this.master.gain.value = v?1:0; }
    play(key, {detuneCents=0, when=0}={}){
      if(!this.enabled) return; const buf=this.buffers.get(key); if(!buf) return;
      const src=this.ctx.createBufferSource(); src.buffer=buf; if(src.detune) src.detune.value=detuneCents;
      src.connect(this.gains.get(key)); src.start(this.ctx.currentTime+when); return src;
    }
    loop(key){
      if(!this.enabled) return; if(this.currentLoops.has(key)) return this.currentLoops.get(key);
      const spec=this.map[key], buf=this.buffers.get(key); if(!buf) return;
      const src=this.ctx.createBufferSource(); src.buffer=buf; src.loop=true;
      const ls=spec.loopStart??0; let le=spec.loopEnd; if(le==null||le<0) le=buf.duration-0.02;
      src.loopStart=Math.max(0,ls); src.loopEnd=Math.max(ls+0.01,le);
      src.connect(this.gains.get(key)); src.start(); this.currentLoops.set(key,src); return src;
    }
    stopLoop(key, fade=0.2){
      const src=this.currentLoops.get(key); if(!src) return;
      const g=this.gains.get(key); const t=this.ctx.currentTime; const from=g.gain.value;
      g.gain.setValueAtTime(from,t); g.gain.linearRampToValueAtTime(0.0001,t+fade);
      setTimeout(()=>{ try{src.stop()}catch{} this.currentLoops.delete(key); g.gain.value=this.map[key]?.gain??1; }, Math.ceil(fade*1000));
    }
    setGain(key, v){ const g=this.gains.get(key); if(g) g.gain.value=v; }
  }

  // ===== App =====
  const VIRTUAL_W=1080, VIRTUAL_H=1920;
  const cfg = { tiltThresholdDeg:35, flowMaxPerSec:0.35, shakeThresholdG:1.2, sloshDamping:0.92 };

  const state = { mode:"Idle_Closed", volume:1.0, tiltDeg:0, shake:0, sparkleCooldown:0, playedKotsun:false };

  // 今の配置（直下のPNG）そのまま使う：
  const images = {
    background: { src: "./Background.png" },  // あれば表示（なくてもOK）
    bottle:     { src: "./Bottle.PNG" },
    cap:        { src: "./Cap.PNG" },
    liquid:     { src: "./Liquid.PNG" },
    surface:    { src: null },                // なくてもOK（ラインで描く）
    sparkles:   { src: "./Sparkles.png" }     // あれば描画（なくてもOK）
  };

  // MP3 も直下に置く（同じ場所）
  const AUDIO_MAP = {
    cap_open: { file:"./cap_pop.mp3",      loop:false, gain:0.9 },
    pour:     { file:"./pour_loop.mp3",    loop:true,  gain:0.8, loopStart:0.02, loopEnd:-1 },
    sparkle:  { file:"./glitter_tinkle.mp3", loop:false, gain:0.7 },
    cap_hit:  { file:"./kotsun.mp3",       loop:false, gain:0.6 }
  };

  const app = { canvas:null, ctx:null, audio:new AudioBus(), lastT:0, accPrev:null,
                cap:{x:540, y:730, r:120, open:false, angle:0}, toastTimer:null };

  function $(s){ return document.querySelector(s); }
  function showToast(msg,ms=1500){ const t=$("#toast"); t.textContent=msg; t.hidden=false; clearTimeout(app.toastTimer); app.toastTimer=setTimeout(()=>t.hidden=true,ms); }

  function loadImages(dict){
    return Promise.all(Object.values(dict).map(obj=>new Promise(res=>{
      if(!obj?.src){ obj.img=null; return res(); }
      const img=new Image(); img.src=obj.src; img.onload=()=>{obj.img=img;res()}; img.onerror=()=>{obj.img=null;res()};
    })));
  }

  async function start(){
    app.canvas=$("#stage"); app.ctx=app.canvas.getContext("2d");
    await loadImages(images);
    await app.audio.init(AUDIO_MAP);
    bindUI();
    requestAnimationFrame(loop);
  }

  function bindUI(){
    $("#btn-start").addEventListener("click", async ()=>{
      $("#overlay").style.display="none";
      await requestMotionPermission();
      if(app.audio?.ctx?.state==="suspended") await app.audio.ctx.resume();
      showToast("準備OK！");
    });
    const btnAudio=$("#btn-audio");
    btnAudio.addEventListener("click", ()=>{
      const on=btnAudio.textContent.includes("🔊");
      btnAudio.textContent=on?"🔇":"🔊"; app.audio.setEnabled(!on);
    });
    $("#btn-help").addEventListener("click", ()=> $("#overlay").style.display="grid");
    app.canvas.addEventListener("pointerdown", (e)=>{
      const pt=getCanvasPoint(e);
      if(hitCap(pt.x,pt.y) && state.mode==="Idle_Closed"){
        state.mode="Idle_Open"; app.cap.open=true; app.cap.angle=-25*Math.PI/180;
        app.audio.play("cap_open"); setTimeout(()=>{ if(!state.playedKotsun){ state.playedKotsun=true; app.audio.play("cap_hit",{detuneCents:Math.random()*40-20}); }},220);
      }
    });
    window.addEventListener("devicemotion", onMotion, {capture:false});
    window.addEventListener("deviceorientation", onOrientation, {capture:false});
    app.canvas.addEventListener("touchmove", e=>e.preventDefault(), {passive:false});
  }

  function getCanvasPoint(e){ const r=app.canvas.getBoundingClientRect(); const rx=(e.clientX-r.left)/r.width, ry=(e.clientY-r.top)/r.height; return {x:rx*VIRTUAL_W, y:ry*VIRTUAL_H}; }
  function hitCap(x,y){ const dx=x-app.cap.x, dy=y-app.cap.y; return dx*dx+dy*dy<=app.cap.r*app.cap.r; }

  async function requestMotionPermission(){
    const DM=window.DeviceMotionEvent, DO=window.DeviceOrientationEvent;
    try{ if(DM&&typeof DM.requestPermission==="function"){ const r=await DM.requestPermission(); if(r!=="granted") showToast("センサー未許可: 揺れ/傾きは使えません"); }
         if(DO&&typeof DO.requestPermission==="function"){ const r2=await DO.requestPermission(); if(r2!=="granted") showToast("センサー未許可: 傾きは使えません"); } }catch(e){}
  }

  function onMotion(ev){
    const a=ev.accelerationIncludingGravity; if(!a) return;
    const mag=Math.sqrt((a.x||0)**2+(a.y||0)**2+(a.z||0)**2)/9.80665;
    if(app.accPrev==null) app.accPrev=mag; const delta=Math.abs(mag-app.accPrev); app.accPrev=mag;
    state.shake=state.shake*0.85+delta*0.15;
    if(state.sparkleCooldown>0) state.sparkleCooldown-=16;
    if(delta>cfg.shakeThresholdG && state.sparkleCooldown<=0){ app.audio.play("sparkle"); state.sparkleCooldown=400; }
  }
  function onOrientation(ev){ const gamma=ev.gamma??0; state.tiltDeg=Math.abs(gamma); }

  function physics(dt){
    const tilt=state.tiltDeg;
    if(state.mode==="Idle_Open" && tilt>cfg.tiltThresholdDeg){ state.mode="Pouring"; app.audio.loop("pour"); }
    if(state.mode==="Pouring"){
      const flow=Math.max(0, Math.min(1,(tilt-cfg.tiltThresholdDeg)/(90-cfg.tiltThresholdDeg)));
      state.volume=Math.max(0, state.volume - flow*cfg.flowMaxPerSec*dt);
      app.audio.setGain("pour", 0.2+0.8*flow);
      if(state.volume<=0){ state.mode="Empty"; app.audio.stopLoop("pour",0.2); }
      if(tilt<=cfg.tiltThresholdDeg){ state.mode="Idle_Open"; app.audio.stopLoop("pour",0.2); }
    }
  }

  function loop(t){ const dt=Math.min(0.05,(t-(app.lastT||t))/1000); app.lastT=t; physics(dt); draw(); requestAnimationFrame(loop); }

  function draw(){
    const ctx=app.ctx; ctx.save(); ctx.clearRect(0,0,VIRTUAL_W,VIRTUAL_H);
    const bg=images.background.img; if(bg){ const s=Math.max(VIRTUAL_W/bg.width, VIRTUAL_H/bg.height); const w=bg.width*s, h=bg.height*s; ctx.drawImage(bg,(VIRTUAL_W-w)/2,(VIRTUAL_H-h)/2,w,h); }
    const cx=VIRTUAL_W/2, cy=VIRTUAL_H*0.62;
    const volH=620*state.volume;
    if(images.liquid.img){ const li=images.liquid.img; const lw=li.width, lh=Math.max(1, li.height*state.volume); ctx.drawImage(li, cx-lw/2, cy-lh/2, lw, lh);
    }else{ ctx.fillStyle="#2fb3ff"; ctx.globalAlpha=.75; ctx.fillRect(cx-220, cy+180-volH, 440, volH); ctx.globalAlpha=1; }
    if(images.bottle.img){ const bi=images.bottle.img; ctx.drawImage(bi, cx-bi.width/2, cy-bi.height/2);
    }else{ ctx.strokeStyle="#88a"; ctx.lineWidth=8; ctx.strokeRect(cx-240, cy-420, 480, 820); }
    const y=cy+180-volH-10;
    if(images.surface?.img){ const si=images.surface.img; ctx.drawImage(si, cx-si.width/2, y-si.height/2); }
    else { ctx.strokeStyle="rgba(255,255,255,.85)"; ctx.beginPath(); ctx.ellipse(cx,y,210,12,0,0,Math.PI*2); ctx.stroke(); }
    ctx.save(); ctx.translate(app.cap.x,app.cap.y); ctx.rotate(app.cap.open?app.cap.angle:0);
    if(images.cap.img){ const ci=images.cap.img; ctx.drawImage(ci,-ci.width/2,-ci.height/2); }
    else { ctx.fillStyle="#d44"; ctx.beginPath(); ctx.arc(0,0,app.cap.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
    if(images.sparkles.img && state.shake>0.1){ const sp=images.sparkles.img; const s=0.8+Math.min(1.6,state.shake)*0.4; ctx.globalAlpha=.7; ctx.drawImage(sp, cx-(sp.width*s)/2, cy-420, sp.width*s, sp.height*s); ctx.globalAlpha=1; }
    ctx.fillStyle="rgba(255,255,255,.9)"; ctx.font="28px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial"; ctx.textAlign="right";
    ctx.fillText(`Tilt: ${state.tiltDeg.toFixed(0)}°`, VIRTUAL_W-16, 40); ctx.fillText(`Vol: ${(state.volume*100)|0}%`, VIRTUAL_W-16, 76);
    ctx.restore();
  }

  window.addEventListener("load", start);
  </script>
</body>
</html>
